2. 给一个非常大的int array，比如百万级以上的，里面有很小部分的数字不是有序的，其他绝大部分都有序，问怎么用接近O(n)来排序。
这题没写代码，只是跟他讨论来着，我说了很多想法，最后大致的结论是遍历的时候，找到明显不是有序的位置，把这个前后扫一小部分，
看看哪边是有序的，就把另一边取出来放到Heap里，如果两边小部分都判断不了是不是该拿出来，就都拿出来，这样扫一遍比如拿出了m
个数字，m << n，之后再loop一遍数组，将这m个heap中的数字插入到其该在的位置，于是数组有序，复杂度大约是O(2n + 2mlogm)。
其实我觉得这个结果也不够严谨，但是大致的思路应该是对的（因为他表示赞同了。。。）

第二个需要开两个新数组A，B，la, lb是A和B的有效长度。因为往老数组插入数据复杂度太高了，只能先分开，然后merge两个排序好的数组。-google 1point3acres
扫描数据cur，如果此数大于等于前A[la - 1], 那么放入A，la++.
如果此数小于A[la - 1]，A[la - 1]和cur都放到数组B，并更新数组B的实际长度，lb+=2，la--。可以一开始设置A[0]=Integer.MIN_VALUE;简化算法实现
sort B之后merge两个数组。这样复杂度是O(2n + mlogm)